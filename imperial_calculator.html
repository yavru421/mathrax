<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Construction Expression Calculator</title>
    <style>
        :root {
            --primary: #2a628f;
            --secondary: #3e92cc;
            --accent: #13293d;
            --light: #e7ecef;
            --dark: #1b1b1e;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: var(--light);
            color: var(--dark);
            line-height: 1.6;
            padding: 16px;
            max-width: 800px;
            margin: 0 auto;
        }
        
        h1 {
            color: var(--primary);
            margin-bottom: 20px;
            text-align: center;
        }
        
        .calculator {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }
        
        .expression-container {
            margin-bottom: 20px;
        }
        
        #expression {
            width: 100%;
            padding: 12px;
            font-size: 18px;
            font-family: monospace;
            border: 2px solid #ddd;
            border-radius: 4px;
            min-height: 60px;
        }
        
        .input-row {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        .input-group {
            flex: 1;
            min-width: 120px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: var (--accent);
        }
        
        input, select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }
        
        .dimension-input {
            display: flex;
            gap: 5px;
            align-items: center;
        }
        
        .dimension-input input, 
        .dimension-input select {
            flex: 1;
        }
        
        .operations {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 8px;
            margin-bottom: 20px;
        }
        
        button {
            background-color: var(--secondary);
            color: white;
            border: none;
            padding: 12px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        
        button:hover {
            background-color: var(--primary);
        }
        
        .result {
            background-color: var(--accent);
            color: white;
            padding: 15px;
            border-radius: 4px;
            margin-top: 20px;
            font-size: 18px;
            white-space: pre-wrap;
        }
        
        .history {
            margin-top: 20px;
        }
        
        .history-item {
            background-color: white;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 4px;
            border-left: 4px solid var(--secondary);
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .history-item:hover {
            background-color: #f5f5f5;
        }
        
        .clear-btn {
            background-color: #e74c3c;
        }
        
        .clear-btn:hover {
            background-color: #c0392b;
        }
        
        .button-group {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
        }
        
        .button-group button {
            flex: 1;
            margin: 0 5px;
        }
        
        .op-btn {
            background-color: var(--primary);
        }
        
        .parenthesis-btn {
            background-color: #555;
        }
        
        @media (max-width: 600px) {
            .input-row {
                flex-direction: column;
                gap: 15px;
            }
            
            .input-group {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <h1>Construction Expression Calculator</h1>
    
    <div class="calculator">
        <div class="expression-container">
            <label for="expression">Expression</label>
            <textarea id="expression" placeholder="Enter calculations like: 5ft6 + 3ft6in or 2ft6 - 1in"></textarea>
        </div>
        
        <div class="operations">
            <button id="backspace-btn">⌫</button>
            <button id="clear-btn" class="clear-btn">Clear</button>
        </div>
        
        <div class="button-group">
            <button id="calculate-btn" style="background-color: #27ae60;">Calculate</button>
        </div>
        
        <div class="result" id="result">
            Result will appear here
        </div>
    </div>
    
    <div class="history">
        <h2>Calculation History</h2>
        <div id="history-list"></div>
        <button id="clear-history" class="clear-btn">Clear History</button>
    </div>

    <script>
        // Token types
        const TOKEN_TYPES = {
            NUMBER: 'NUMBER',
            OPERATOR: 'OPERATOR',
            LEFT_PAREN: 'LEFT_PAREN',
            RIGHT_PAREN: 'RIGHT_PAREN',
            MEASUREMENT: 'MEASUREMENT'
        };
        
        // Precedence of operators
        const PRECEDENCE = {
            '+': 1,
            '-': 1,
            '×': 2,
            '÷': 2
        };
        
        // Utility functions for measurements
        function gcd(a, b) {
            a = Math.abs(a);
            b = Math.abs(b);
            return b ? gcd(b, a % b) : a;
        }
        
        function toFraction(decimal) {
            // Round to nearest 1/16th
            const precision = 16;
            const roundedDecimal = Math.round(decimal * precision) / precision;
            
            if (roundedDecimal === 0) return "0";
            
            // Convert to 16ths
            const denominator = 16;
            const numerator = Math.round(roundedDecimal * denominator);
            
            if (numerator === 0) return "0";
            
            const divisor = gcd(numerator, denominator);
            const simplifiedNum = numerator / divisor;
            const simplifiedDenom = denominator / divisor;
            
            return simplifiedNum + "/" + simplifiedDenom;
        }
        
        function formatMeasurement(totalInches) {
            if (totalInches === 0) return "0";
            
            // Handle negative values
            const isNegative = totalInches < 0;
            totalInches = Math.abs(totalInches);
            
            // Convert to feet and inches
            const feet = Math.floor(totalInches / 12);
            const remainingInches = totalInches % 12;
            const wholeInches = Math.floor(remainingInches);
            const fractionInches = remainingInches - wholeInches;
            
            let result = "";
            
            if (feet > 0) {
                result += `${feet}ft`;
                
                if (wholeInches > 0 || fractionInches > 0) {
                    result += " ";
                }
            }
            
            if (wholeInches > 0 || fractionInches > 0) {
                if (fractionInches === 0) {
                    result += `${wholeInches}in`;
                } else {
                    const fractionStr = toFraction(fractionInches);
                    
                    if (wholeInches === 0) {
                        result += `${fractionStr}in`;
                    } else {
                        result += `${wholeInches}&${fractionStr}in`;
                    }
                }
            }
            
            return isNegative ? "-" + result : result;
        }
        
        // Lexer - breaks input string into tokens
        function tokenize(input) {
            const tokens = [];
            let i = 0;
            
            while (i < input.length) {
                const char = input[i];
                
                // Skip whitespace
                if (/\s/.test(char)) {
                    i++;
                    continue;
                }
                
                // Handle numbers (including decimals)
                if (/[0-9]/.test(char)) {
                    let num = '';
                    while (i < input.length && (/[0-9.]/.test(input[i]))) {
                        num += input[i++];
                    }
                    tokens.push({ type: TOKEN_TYPES.NUMBER, value: parseFloat(num) });
                    continue;
                }
                
                // Handle measurements with & format like 6&1/2in
                if (/[0-9]/.test(char) && i + 2 < input.length && input[i + 1] === '&') {
                    let wholeNumber = '';
                    // Get the whole number part
                    while (i < input.length && /[0-9]/.test(input[i])) {
                        wholeNumber += input[i++];
                    }
                    
                    // Skip the & character
                    if (i < input.length && input[i] === '&') {
                        i++;
                    } else {
                        // This isn't an & format, so revert and try other patterns
                        i -= wholeNumber.length;
                        continue;
                    }
                    
                    // Parse the fraction part
                    let numerator = '';
                    let denominator = '';
                    
                    // Get numerator
                    while (i < input.length && /[0-9]/.test(input[i])) {
                        numerator += input[i++];
                    }
                    
                    // Skip the / character
                    if (i < input.length && input[i] === '/') {
                        i++;
                    } else {
                        throw new Error(`Invalid fraction format after &`);
                    }
                    
                    // Get denominator
                    while (i < input.length && /[0-9]/.test(input[i])) {
                        denominator += input[i++];
                    }
                    
                    // Skip the in character if present
                    if (i < input.length && input[i] === 'i' && input[i + 1] === 'n') {
                        i += 2;
                    }
                    
                    // Convert to number value
                    const whole = parseInt(wholeNumber);
                    const fraction = parseInt(numerator) / parseInt(denominator);
                    const totalValue = whole + fraction;
                    
                    tokens.push({ type: TOKEN_TYPES.NUMBER, value: totalValue });
                    continue;
                }
                
                // Handle measurements like 5ft6in or 5ft 6in or 5ft6 1/2in
                if (/[0-9]/.test(char) && i + 2 < input.length && input[i + 1] === 'f' && input[i + 2] === 't') {
                    let measurementStr = '';
                    let inchesFound = false;
                    
                    // Collect the entire measurement string
                    while (i < input.length &&
                        ((/[0-9ftin\s\/&]/.test(input[i])) ||
                            (input[i] === " " && !inchesFound))) {
                        measurementStr += input[i];
                        if (input[i] === 'i' && input[i + 1] === 'n') inchesFound = true;
                    i++;
                }

                // Parse the measurement
                let totalInches = 0;

                // Extract feet
                const feetMatch = measurementStr.match(/(\d+)ft/);
                if (feetMatch) {
                    totalInches += parseInt(feetMatch[1]) * 12;
                }

                // Extract inches with fraction
                const inchesMatch = measurementStr.match(/(\d+)\s*&?\s*(\d+)\/(\d+)in/);
                if (inchesMatch) {
                    totalInches += parseInt(inchesMatch[1]);
                    totalInches += parseInt(inchesMatch[2]) / parseInt(inchesMatch[3]);
                } else {
                    // Extract just inches
                    const justInchesMatch = measurementStr.match(/(\d+)in/);
                    if (justInchesMatch) {
                        totalInches += parseInt(justInchesMatch[1]);
                    }

                    // Extract just fraction inches
                    const justFractionMatch = measurementStr.match(/(\d+)\/(\d+)in/);
                    if (justFractionMatch) {
                        totalInches += parseInt(justFractionMatch[1]) / parseInt(justFractionMatch[2]);
                    }
                }

                tokens.push({ type: TOKEN_TYPES.NUMBER, value: totalInches });
                continue;
            }

            // Handle standalone fractions like 1/2in
            if (/[0-9]/.test(char) && i + 2 < input.length && input[i + 1] === '/' && /[0-9]/.test(input[i + 2])) {
                let numerator = '';
                // Get the numerator
                while (i < input.length && /[0-9]/.test(input[i])) {
                    numerator += input[i++];
                }

                // Skip the / character
                if (input[i] === '/') {
                    i++;
                } else {
                    // This isn't a fraction, revert and try other patterns
                    i -= numerator.length;
                    continue;
                }

                // Get the denominator
                let denominator = '';
                while (i < input.length && /[0-9]/.test(input[i])) {
                    denominator += input[i++];
                }

                // Skip the in character if present
                if (i < input.length && input[i] === 'i' && input[i + 1] === 'n') {
                    i += 2;
                }

                // Convert the fraction to a decimal
                const decimal = parseInt(numerator) / parseInt(denominator);
                tokens.push({ type: TOKEN_TYPES.NUMBER, value: decimal });
                continue;
            }

            // Handle operators
            if (['+', '-', '×', '÷'].includes(char)) {
                tokens.push({ type: TOKEN_TYPES.OPERATOR, value: char });
                i++;
                continue;
            }

            // Handle parentheses
            if (char === '(') {
                tokens.push({ type: TOKEN_TYPES.LEFT_PAREN });
                i++;
                continue;
            }

            if (char === ')') {
                tokens.push({ type: TOKEN_TYPES.RIGHT_PAREN });
                i++;
                continue;
            }

            // If we've reached here, we have an unknown character
            throw new Error(`Unknown token: ${char}`);
        }

        return tokens;
    }

    // Parser using Shunting Yard algorithm to evaluate the expression
    function evaluate(tokens) {
        const outputQueue = [];
        const operatorStack = [];

        // Convert infix to postfix using Shunting Yard
        for (const token of tokens) {
            switch (token.type) {
                case TOKEN_TYPES.NUMBER:
                    outputQueue.push(token);
                    break;

                case TOKEN_TYPES.OPERATOR:
                    while (
                        operatorStack.length > 0 &&
                        operatorStack[operatorStack.length - 1].type === TOKEN_TYPES.OPERATOR &&
                        PRECEDENCE[operatorStack[operatorStack.length - 1].value] >= PRECEDENCE[token.value]
                    ) {
                        outputQueue.push(operatorStack.pop());
                    }
                    operatorStack.push(token);
                    break;

                case TOKEN_TYPES.LEFT_PAREN:
                    operatorStack.push(token);
                    break;

                case TOKEN_TYPES.RIGHT_PAREN:
                    while (
                        operatorStack.length > 0 &&
                        operatorStack[operatorStack.length - 1].type !== TOKEN_TYPES.LEFT_PAREN
                    ) {
                        outputQueue.push(operatorStack.pop());
                    }

                    // Discard the left parenthesis
                    if (operatorStack.length > 0 && operatorStack[operatorStack.length - 1].type === TOKEN_TYPES.LEFT_PAREN) {
                        operatorStack.pop();
                    } else {
                        throw new Error("Mismatched parentheses");
                    }
                    break;
            }
        }

        // Pop all remaining operators to the output queue
        while (operatorStack.length > 0) {
            const op = operatorStack.pop();
            if (op.type === TOKEN_TYPES.LEFT_PAREN) {
                throw new Error("Mismatched parentheses");
            }
            outputQueue.push(op);
        }

        // Evaluate the postfix expression
        const evaluationStack = [];

        for (const token of outputQueue) {
            if (token.type === TOKEN_TYPES.NUMBER) {
                evaluationStack.push(token.value);
            } else if (token.type === TOKEN_TYPES.OPERATOR) {
                if (evaluationStack.length < 2) {
                    throw new Error("Invalid expression");
                }

                const b = evaluationStack.pop();
                const a = evaluationStack.pop();

                switch (token.value) {
                    case '+':
                        evaluationStack.push(a + b);
                        break;
                    case '-':
                        evaluationStack.push(a - b);
                        break;
                    case '×':
                        evaluationStack.push(a * b);
                        break;
                    case '÷':
                        if (b === 0) {
                            throw new Error("Division by zero");
                        }
                        evaluationStack.push(a / b);
                        break;
                }
            }
        }

        if (evaluationStack.length !== 1) {
            throw new Error("Invalid expression");
        }

        return evaluationStack[0];
    }

    // Calculator functionality
    function calculateExpression() {
        const expressionInput = document.getElementById("expression").value.trim();

        if (!expressionInput) {
            document.getElementById("result").textContent = "Please enter an expression";
            return;
        }

        try {
            const tokens = tokenize(expressionInput);
            const result = evaluate(tokens);

            // Format the result as a construction measurement
            const formattedResult = formatMeasurement(result);
            document.getElementById("result").textContent = formattedResult;

            // Add to history
            addToHistory(expressionInput);
            saveHistory();

            return result;
        } catch (error) {
            document.getElementById("result").textContent = `Error: ${error.message}`;
            return null;
        }
    }

    // History functions
    let inputHistory = [];
    let historyIndex = -1;

    function addToHistory(text) {
        if (inputHistory[0] !== text) {
            inputHistory.unshift(text);
            historyIndex = -1; // Reset index when a new calculation is added
        }
